#include <iostream>
#include <stack>
#include <algorithm>
class MinStack {
private:
    std::stack<int> mainStack; 
    std::stack<int> minStack;   
public:
    MinStack() {}
    void push(int x) {
        mainStack.push(x);
        if (minStack.empty()) {
            minStack.push(x);
        } else {
            minStack.push(std::min(x, minStack.top()));
        }
    }
    void pop() {
        if (!mainStack.empty()) {
            mainStack.pop();
            minStack.pop();
        }
    }
    int top() {
        if (!mainStack.empty()) {
            return mainStack.top();
        }
        throw std::runtime_error("Stack is empty");
    }
    int getMin() {
        if (!minStack.empty()) {
            return minStack.top();
        }
        throw std::runtime_error("Stack is empty");
    }
};
int main() {
    MinStack minStack;
    minStack.push(10);
    std::cout << "Top: " << minStack.top() << ", Min: " << minStack.getMin() << std::endl;

    minStack.push(20);
    std::cout << "Top: " << minStack.top() << ", Min: " << minStack.getMin() << std::endl;

    minStack.push(5);
    std::cout << "Top: " << minStack.top() << ", Min: " << minStack.getMin() << std::endl;

    minStack.pop();
    std::cout << "After popping, Top: " << minStack.top() << ", Min: " << minStack.getMin() << std::endl;

    minStack.pop();
    std::cout << "After popping again, Top: " << minStack.top() << ", Min: " << minStack.getMin() << std::endl;

    return 0;
}
